# 스레드 풀과 Executor 프레임워크

## 1. 스레드를 직접 사용할 때의 문제점
- 1. 스레드 생성 비용으로 인한 성능 문제
- 2. 스레드 관리 문제
- 3. Runnable 인터페이스의 불편함

### 1-1. 스레드 생성 비용으로 인한 성능 문제
스레드를 사용하려면 먼저 스레드를 생성해야 한다. 그런데 스레드는 다음과 같은 이유로 매우 무겁다.
- 메모리 할당 : 각 스레드는 자신만의 호출 스택(call stack)을 가지고 있어야 한다. 이 호출 스택은 스레드가 실행되는 동안 사용하는 메모리 공간이다.
- 운영체제 자원 사용 : 스레드를 생성하는 작업은 운영체제 커널 수준에서 이루어지며, 시스템 콜(system call)을 통해 처리된다.
- 운영체제 스케줄러 설정 : 새로운 스레드가 생성되면 운영체제의 스케줄러는 이 스레드를 관리하고 실행 순서를 조정해야 한다.
이런 문제를 해결하려면 생성한 스레드를 재사용하는 방법을 고려할 수 있다. 스레드를 재사용하면 처음 생성할 때를 제외하고는 생성을 위한 시간이 들지 않는다.

### 1-2. 스레드 관리 문제
- 서버의 CPU, 메모리 자원은 한정되어 있기 때문에, 스레드는 무한하게 만들 수 없다.
- 예를 들어, 사용자의 주문을 처리하는 서비스라고 가정한다.
- 평소 동시에 100개 정도의 스레드면 충분했는데, 갑자기 10000개의 스레드가 필요한 상황이 된다면, CPU, 메모리 자원이 버티지 못할 것이다.
- 또한, 다음과 같은 문제도 있다.
- 애플리케이션을 종료해야 할 때, 안전한 종료를 위해 실행 중인 스레드가 남은 작업은 모두 수행한 다음에 프로그램을 종료해야 하는 상황이라 가정한다.
- 이런 경우에도 스레드가 어딘가에 관리가 되어 있어야 한다.

### 1-3. Runnable 인터페이스의 불편함
```
public interface Runnable {
  void run();
}
```
Runnable 인터페이스는 다음과 같은 이유로 불편하다.
- 반환 값이 없다 : run() 메서드는 반환 값을 가지지 않는다. 따라서 실행 결과를 얻기 위해서는 별도의 매커니즘을 사용해야 한다.
쉽게 이야기해서 스레드의 실행 결과를 직접 받을 수 없다. 
스레드가 실행한 결과를 멤버 변수에 넣어두고, join() 등을 사용해서 스레드가 종료되길 기다린 다음에 멤버 변수에 보관한 값을 받아야 한다.
- 예외 처리 : run() 메서드는 체크 예외(checked exception)를 던질 수 없다. 체크 예외의 처리는 메서드 내부에서 처리해야 한다.
이런 문제를 해결하려면 반환 값도 받을 수 있고, 해당 스레드에서 발생한 예외도 받을 수 있는 방법이 필요하다.

### 1-4. 해결
- 지금까지 설명한 문제를 해결하려면 스레드를 생성하고 관리하는 풀(Pool)이 필요하다.
- 스레드를 관리하는 스레드 풀에 스레드를 미리 필요한 만큼 만들어둔다.
  - 1. 스레드는 스레드 풀에서 대기하며 쉰다.
  - 2. 작업 요청이 온다.
  - 3. 스레드 풀에서 이미 만들어진 스레드를 하나 조회한다.
  - 4. 조회한 스레드1로 작업을 처리한다.
  - 5. 스레드1은 작업을 완료한다.
  - 6. 작업을 완료한 스레드는 종료하는게 아니라, 다시 스레드 풀에 반납한다. 스레드1은 이후에 다시 재사용될 수 있다.

## 2. Executor 프레임워크 소개 (p.23)
### 2-1. Executor 프레임워크의 주요 구성 요소
```
public interface Executor {
  void execute(Runnable command);
}
```


