# 1. ReentrantLock
:자바는 synchronized와 BLOCKED 상태를 통한 임계 영역 관리의 한계를 극복하기 위해 Lock 인터페이스와 ReentrantLock 구현체를 제공한다.

## 1-1. Lock 인터페이스 설명 : 무한대기 문제 해결
- 동시성 프로그래밍에서 쓰이는 안전한 임계 영역을 위한 락을 구현하는데 사용된다.
- Lock 인터페이스는 다음과 같은 메서드를 제공한다. 대표적인 구현체로 ReentrantLock이 있다.
- `void lock()` : 락을 획득한다. 만약 다른 스레드가 이미 락을 획득했다면, 락이 풀릴 때까지 현재 스레드는 대기(WAITING)한다. 이 메서드는 인터럽트에 응답하지 않는다.
- `void lockInterruptibly()` : 락 획득을 시도하되, 다른 스레드가 인터럽트할 수 있도록 한다. 만약 다른 스레드가 이미 락을 획득했다면, 현재 스레드는 락을 획득할 때까지 대기한다.
  대기 중에 인터럽트가 발생하면 InterruptedException이 발생하며 락 획득을 포기한다.
- `boolean tryLock()` : 락 획득을 시도하고, 즉시 성공 여부를 반환한다. 만약 다른 스레드가 이미 락을 획득했다면 false를 반환하고, 그렇지 않으면 락을 획득하고 true를 반환한다.
- `boolean tryLock(long time, TimeUnit unit)` : 주어진 시간동안 락 획득을 시도한다. 주어진 시간 안에 락을 획득하면 true를 반환한다. 주어진 시간이 지나도 락을 획득하지 못한 경우 false를 반환한다.
   이 메서드는 대기 중 인터럽트가 발생하면 InterruptedException이 발생하며 락 획득을 포기한다.
- `void unlock()` : 락을 해제한다. 락을 해제하면 락 획득을 대기 중인 스레드 중 하나가 락을 획득할 수 있게 된다.
  락을 획득한 스레드가 호출해야 하며, 그렇지 않으면 IllegalMonitorStateException이 발생할 수 있다.
- `Condition newCondition()` : Condition 객체를 생성하여 반환한다. Condition 객체는 락과 결합되어 사용되며, 스레드가 특정 조건을 기다리거나 신호를 받을 수 있도록 한다.
  이는 Object 클래스의 wait, notify, notifyAll 메서드와 유사한 역할을 한다.

## 1-2. 공정성 문제 해결
: Lock 인터페이스의 대표적인 구현체로 ReentrantLock이 있는데, 이 클래스는 스레드가 공정하게 락을 얻을 수 있는 모드를 제공한다.

### 1-2-1. 비공정 모드(Non-fair mode)
- 비공정 모드는 ReentrantLock의 기본 모드이다. 이 모드에서는 락을 먼저 요청한 스레드가 락을 먼저 획득한다는 보장이 없다.
- 락을 풀었을 때, 대기 중인 스레드 중 아무나 락을 획득할 수 있다. 이는 락을 빨리 획득할 수 있지만, 특정 스레드가 장기간 락을 획득하지 못할 가능성도 있다.
-  성능 우선 : 락을 획득하는 속도가 빠르다.
-  선점 가능 :  새로운 스레드가 기존 대기 스레드보다 먼저 락을 획득할 수 있다.
-  기아 현상 가능성 : 특정 스레드가 계속해서 락을 획득하지 못할 수도 있다.

### 1-2-2. 공정 모드(Fair mode)
- 생성자에서 true를 전달하면 된다. 예) new ReentrantLock(true)
- 공정 모드는 락을 요청한 순서대로 락을 획득할 수 있게 한다. 이는 먼저 대기한 스레드가 먼저 락을 획득하게 되어 스레드 간의 공정성을 보장한다. 그러나 이로 인해 성능이 저하될 수 있다.
- 공정성 보장 : 대기 큐에서 먼저 대기한 스레드가 락을 먼저 획득한다.
- 기아 현상 방지 : 모든 스레드가 언젠가 락을 획득할 수 있게 보장된다.
- 성능 저하 : 락을 획득하는 속도가 느려질 수 있다.

### 1-2-3. 정리
- 비공정 모드는 성능을 중시하고, 스레드가 락을 빨리 획득할 수 있지만, 특정 스레드가 계속해서 락을 획득하지 못할 수도 있다.
- 공정 모드는 스레드가 락을 획득하는 순서를 보장하여 공정성을 중시하지만, 성능이 저하될 수 있다.

## 1-3. 예제
### 1-3-1. 가정
- t1, t2가 출금을 시작한다. 여기서는 t1이 약간 먼저 실행된다고 가정한다
- ReentrantLock의 내부에는 락과 락을 얻지 못해 대기하는 스레드를 관리하는 대기 큐가 존재한다.
- 여기서 이야기하는 락은 객체 내부에 있는 모니터 락이 아니다. ReentrantLock이 제공하는 기능이다.

### 1-3-2. 실행결과
- t1 : ReentrantLock에 있는 락을 획득한다. 락을 획득하였으므로 RUNNABLE 상태가 유지되고, 임계 영역의 코드를 실행한다.
- t2 : ReentrantLock에 있는 락의 획득을 시도한다. 하지만 락이 없다.
- t2 : 락을 획득하지 못하면  WAITING 상태가 되고, 대기 큐에서 관리된다. (LockSupport.park()가 내부에서 호출된다.)
- t1 : 임계 영역의 수행을 완료했다.이때 잔액은 balance =200 이 된다.
- t1 : 임계 영역을 수행하고 나면 lock.unlock()을 호출한다.
   - 1. t1 : 락을 반납한다.
   - 2. t1 : 대기 큐의 스레드를 하나 깨운다. LockSupport.unpark(thread)가 내부에서 호출된다.
   - 3. t2 : RUNNABLE 상태가 되면서 깨어난 스레드는 락 획득을 시도한다.
      - 이때 락을 획득하면 lock.lock()을 빠져나오면서 대기 큐에서도 제거된다.
      - 이때 락을 획득하지 못하면 다시 대기 상태가 되면서 대기 큐에 유지된다.
- t2 : 락을 획득한 t2 스레드는 RUNNABLE 상태로 임계 영역을 수행한다.
- t2 : 검증 로직을 통과하지 못하여 검증실패이다. return false가 호출된다.
- 이때 finally 구문이 있으므로 finally 구문으로 이동한다.
- t2 : lock.unlock()을 호출해서 락을 반납하고, 대기 큐의 스레드를 하나 깨우려고 시도한다. 대기 큐에 스레드가 없으므로 이때는 깨우지 않는다.

  ## 1-4. 대기 중단
  : ReentrantLock을 사용하면 락을 무한 대기하지 않고, 중간에 빠져나오는 것이 가능하다. 심지어 락을 얻을 수 없다면 기다리지 않고 즉시 빠져나오는 것도 가능하다.

  ### 1-4-1. tryLock() 예시
  ```
  if(!lock.tryLock()) {
    return false;
  }
  ```
  - lock.tryLock()에서 false가 반환되므로 메서드를 종료한다.

  ### 1-4-2. tryLock(시간) 예시
  ```
  if(!lock.tryLock(500, TimeUnit.MILLISECONDS)) {
    return false;
  }
  ```
  - lock.tryLock(0.5초)을 호출하고 락 획득을 시도한다.
  - 락이 없으므로 0.5초간 대기한다.
     - 이때 t2는 TIMED_WAITING 상태가 된다.
     - 내부에서는 LockSupport.parkNanos(시간)이 호출된다.
  - t2 : 대기 시간인 0.5초간 락을 획득하지 못했다. lock.tryLock(시간)에서 즉시 빠져나온다.(false 반환)
     - 스레드는 TIMED_WAITING -> RUNNABLE이 된다.
  - t2 : 메서드를 종료한다.
