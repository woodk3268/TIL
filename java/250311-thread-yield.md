# thread yield
- 어떤 스레드를 얼마나 실행할지는 운영체제가 스케줄링을 통해 결정한다.
- 그런데 특정 스레드가 다른 스레드에 CPU 실행 기회를 양보하고 싶을 수 있다.
- 이렇게 양보하면 스케줄링 큐에 대기 중인 다른 스레드가 CPU 실행 기회를 더 빨리 얻을 수 있다.

## 1. Empty
- 특정 스레드가 쭉 수행된 다음에 다른 스레드가 수행되는 것 확인된다.
- 다른 예시보다 상대적으로 하나의 스레드가 쭉 연달아 실행되다가 다른 스레드로 넘어간다.
  
## 2. sleep()
- sleep(1)을 사용해서 스레드의 상태를 1밀리초 동안 아주 잠깐 RUNNABLE -> TIMED_WAITING으로 변경
- 이렇게 되면 스레드는 CPU 자원을 사용하지 않고, 실행 스케줄링에서 잠시 제외된다.
- 결과적으로 TIMED_WAITING 상태가 되면서 다른 스레드에 실행을 양보하게 된다.
- 그리고 스케줄링 큐에 대기 중인 다른 스레드가 CPU의 실행 기회를 빨리 얻을 수 있다.
- 1밀리초의 대기 시간 이후 다시 TIMED WAITING -> RUNNABLE 상태가 되면서 실행 스케줄링에 포함된다.

- 단점
- RUNNABLE -> TIMED_WAITING -> RUNNABLE 로 변경되는 복잡한 과정을 거치고, 또 특정 시간만큼 스레드가 실행되지 않는 단점이 있다.
- 예를 들어, 양보할 스레드가 없는 상황에서 나머지 스레드가 모두 대기 상태로 쉬고 있어도 내 스레드까지 잠깐 실행되지 않는다.

## 3. yield()
- 자바의 스레드가 RUNNBLE 상태일 때, 운영체제의 스케줄링은 다음과 같은 상태들을 가질 수 있다.
  - 실행 상태(Running) : 스레드가 CPU에서 실제로 실행 중이다.
  - 실행 대기 상태(Ready) : 스레드가 실행될 준비가 되었지만, CPU가 바빠서 스케줄링 큐에서 대기 중
- 운영체제는 실행 상태의 스레드들을 잠깐만 실행하고 실행 대기 상태로 만든다. 그리고 실행 대기 상태의 스레드들을 잠깐만 실행 상태로 변경해서 실행한다. 이 과정을 계속 반복한다.

  - Thread.yield() 메서드는 현재 실행 중인 스레드가 자발적으로 CPU를 양보하여 다른 스레드가 실행될 수 있도록 한다.
  - yield() 메서드를 호출한 스레드는 RUNNABLE 상태를 유지하면서 CPU를 양보한다. 즉, 이 스레드는 다시 스케줄링 큐에 들어가면서 다른 스레드에게 CPU 사용 기회를 넘긴다.
  - yield()는 운영체제의 스케줄러에게 단지 힌트를 제공할 뿐, 강제적인 실행 순서를 지정하지 않는다.
  - yield() 는 RUNNABLE 상태를 유지하기 때문에, 쉽게 이야기해서 양보할 사람이 없다면 본인 스레드가 계속 실행될 수 있다.
 
## 4. 250310-thread-interrupted-ex 에 yield 도입
- 인터럽트가 발생하기 전까지 계속 인터럽트의 상태를 체크하고 또 jobQueue의 상태를 확인한다.
- 현재 작동하는 스레드가 아주 많은 상황이라고 가정해본다.
- 인터럽트도 걸리지 않고, jobQueue도 비어있는데, 이런 체크 로직에 CPU 자원을 많이 사용하게 되면, 정작 필요한 스레드들의 효율이 상대적으로 떨어질 수 있다.
- 차라리 그 시간에 다른 스레드들을 더 많이 실행해서 jobQueue에 필요한 작업을 빠르게 만들어 넣어주는 게 더 효율적일 것이다.
- jobQueue에 작업이 비어있으면 yield()를 호출해서, 다른 스레드에 작업을 양보하도록 한다.
