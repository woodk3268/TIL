# 1. 동기화 - synchronized

## 1-1. 동시성 문제
- 정의 : 같은 자원(리소스)에 여러 스레드가 동시에 접근할 때 발생하는 동시성 문제
- 참고로 여러 스레드가 접근하는 자원을 공유자원이라 하는데, 대표적인 공유자원은 인스턴스의 필드(멤버 변수)임.
- 멀티스레드를 사용할 대는 이런 공유 자원에 대한 접근을 적절하게 동기화해서 동시성 문제가 발생하지 않게 방지하는 것이 중요함.

## 1-2. 예제
- main 스레드는 t1, t2 스레드를 만든다. 만든 스레드들은 같은 계좌에 각각 800원의 출금을 시도한다.
- main 스레드는 join()을 사용해서 t1, t2 스레드가 출금을 완료한 이후에 최종 잔액을 확인한다.

### 1-2-1. t1, t2 순서로 실행 가정
- t1이 약간 먼저 실행되면서, 출금을 시도한다.
- t1이 출금 코드에 있는 검증 로직을 실행한다. 이때 잔액이 출금 액수보다 많은지 확인한다.
  - 잔액이 출금액보다 많으므로 검증로직을 통과한다.
- t1 : 출금 검증 로직을 통과해서 출금을 위해 잠시 대기중이다.
- t2 : 검증 로직을 실행한다. 잔액이 출금 금액보다 많은지 확인한다.
   - 잔액이 출금액보다 많으므로 검증로직을 통과한다.
     
**=> t1이 검증로직을 통과하고 잔액을 줄이기도 전에 먼저 t2가 검증 로직을 확인한 것이다.**
- 다만, 이 과정에서는 t1->t2 순차적으로 잔액 차감하므로 1000 -> 200 -> -600 으로 변경된다.(1000원에서 800원씩 차감 가정) 

### 1-2-2. t1, t2 동시에 실행 가정
- t1, t2는 동시에 검증 로직을 실행한다. 잔액이 출금 금액보다 많은지 확인한다.
  - 잔액이 출금액보다 많으므로 둘다 통과한다.
- 결과적으로 t1, t2 모두 검증 로직을 통과하고, 출금을 위해 잠시 대기중이다.
- t1, t2는 둘 다 동시에 계산된 결과를 잔액에 반영하는데, 둘 다 계산된 결과인 200원을 반영하므로 최종 잔액은 200원이 된다.(1000원에서 800원씩 차감 가정)


## 1-3. 임계영역의 필요성
: 이런 문제가 발생한 근본 원인은 여러 스레드가 함께 사용하는 공유 자원을 여러 단계로 나누어 사용하기 때문이다.
- 1. 검증 단계 : 잔액이 출금액보다 많은지 확인한다.
- 2. 출금 단계 : 잔액을 출금액만큼 줄인다.
 
```
출금() {
  1. 검증 단계 : 잔액(balance) 확인
  2. 출금 단계 : 잔액(balance)을 출금액만큼 줄인다.
}
```

**이 로직에는 하나의 큰 가정이 있다.**
- 스레드 하나의 관점에서 출금()을 보면 1. 검증 단계에서 확인한 잔액(balance) 1000원은 2. 출금 단계에서 계산을 끝마칠 때까지 같은 1000원으로 유지되어야 한다.
- 그래야 검증 단계에서 확인한 금액으로, 출금 단계에서 정확한 잔액을 계산할 수 있다.
- 결국 여기서는 내가 사용하는 값이 중간에 변경되지 않을 것이라는 가정이 있다.

## 1-3-1. 공유자원
- 잔액(balance)은 여러 스레드가 함께 사용하는 공유 자원이다.
- 참고로 여기서는 출금() 메서드를 호출할 때만 잔액(balance)의 값이 변경된다.
- 따라서, 다른 스레드가 출금 메서드를 호출하면서, 사용중인 출금 값을 중간에 변경해버릴 수 있다.

## 1-3-2. 한 번에 하나의 스레드만 실행
- 만약 출금()이라는 메서드를 한 번에 하나의 스레드만 실행할 수 있게 제한한다면 어떻게 될까?
- 예를 들어 t1, t2 스레드가 함께 출금()을 호출하면 t1 스레드가 먼저 처음부터 끝까지 출금() 메서드를 완료하고, 그 다음에 t2 스레드가 처음부터 끝까지 출금() 메서드를 완료하는 것이다.
- 이렇게 하면 공유 자원인 balance를 한 번에 하나의 스레드만 변경할 수 있다. 따라서 계산 중간에 다른 스레드가 balance의 값을 변경하는 부분을 걱정하지 않아도 된다.
   - 더 자세히는 출금을 진행할 때 잔액(balance)을 검증하는 단계부터 잔액의 계산을 완료할 때까지 잔액의 값은 중간에 변하면 안된다.
   - 이 검증과 계산 이 두 단계는 한 번에 하나의 스레드만 실행해야 한다. 그래야 잔액이 중간에 변하지 않고, 안전하게 계산을 수행할 수 있다.
 
## 1-3-3. 임계 영역(critical section)
- 여러 스레드가 동시에 접근하면 데이터 불일치나 예상치 못한 동작이 발생할 수 있는 위험하고 또 중요한 코드 부분을 뜻한다.
- 여러 스레드가 동시에 접근해서는 안 되는 공유 자원을 접근하거나 수정하는 부분을 의미한다.
- 예) 공유 변수나 공유 객체를 수정

## 1-4. synchronized 메서드
- 자바는 synchronized 키워드를 사용하면 한 번에 하나의 스레드만 실행할 수 있는 코드 구간을 만들 수 있다.

## 1-4-1. synchronized 분석
- 모든 객체(인스턴스)는 내부에 자신만의 락(lock)을 가지고 있다.
   - 모니터 락(monitor lock)이라고도 부른다.
   - 객체 내부에 있고 우리가 확인하기는 어렵다.
- 스레드가 synchronized 키워드가 있는 메서드에 진입하려면 반드시 해당 인스턴스의 락이 있어야 한다.

## 1-4-2. synchronized 예제
- t1, t2 두 스레드 중 t1이 먼저 실행된다고 가정한다.
- 스레드 t1이 먼저 synchronized 키워드가 있는 withdraw() 메서드를 호출한다.
- synchronized 메서드를 호출하려면 먼저 해당 인스턴스의 락이 필요하다.
- 락이 있으므로 스레드 t1은 x001 인스턴스에 있는 락을 획득한다.
- 스레드 t1은 해당 인스턴스의 락을 획득했기 때문에 withdraw() 메서드에 진입할 수 있다.
- 스레드 t2도 withdraw() 메서드 호출을 시도한다. synchronized 메서드를 호출하려면 먼저 해당 인스턴스의 락이 필요하다.
- 스레드 t2는 x001 인스턴스에 있는 락 획득을 시도한다.
- 하지만 락이 없다. 이렇게 락이 없으면 t2 스레드는 락을 획득할 때까지 BLOCKED 상태로 대기한다.(RUNNABLE -> BLOCKED)
- t2 : 인스턴스에 락이 반납되면 락 획득을 대기하는 스레드는 자동으로 락을 획득한다.
- 이때, 락을 획득한 스레드는 BLOCKED -> RUNNABLE 상태가 되고, 다시 코드를 실행한다.
