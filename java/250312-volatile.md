# volatile

## 1. volatile 의 필요성
- main 스레드와 work 스레드 간 공유하는 변수에 volatile 키워드 미사용
- ``` boolean runFlag = true; ```

- main 스레드는 새로운 스레드인 work 스레드를 생성하고 작업을 시킨다.
- work 스레드는 run() 메서드를 실행하면서 while(runFlag)가 true인 동안 계속 작업을 한다.
- 만약 runFlag가 false로 변경되면 반복문을 빠져나오면서 "task 종료"를 출력하고 작업을 종료한다.
- main 스레드는 sleep()을 통해 1초간 쉰 다음에 runFlag를 false로 설정한다.
- work 스레드는 run() 메서드를 실행하면서 while(runFlag)를 체크하는데, 이제 runFlag가 false가 되었으므로 "task 종료"를 출력하고 작업을 종료해야 한다.
- 
- 그러나 실제 실행 결과를 보면 task 종료가 출력되지 않는다.
- work 스레드가 while문에서 빠져나오지 못하고 있다.

## 2. volatile, 메모리 가시성
### 2-1. 일반적으로 생각하는 메모리 접근 방식
- main 스레드와 work 스레드는 각각의 CPU 코어에 할당되어서 실행된다.
  
- 자바 프로그램을 실행하고 main 스레드와 work 스레드는 모두 메인 메모리의 runFlag의 값을 읽는다.
- 프로그램의 시작 시점에는 runFlag를 변경하지 않기 때문에 모든 스레드에서 true의 값을 읽는다.
- work 스레드의 경우 while(runFlag[true])가 만족하기 때문에 while문을 계속 반복해서 수행한다.
  - main 스레드는 runFlag 값을 false로 설정한다.
  - 이때 메인 메모리의 runFlag 값이 false로 설정된다.
  - work 스레드는 while(runFlag)를 실행할 때 runFlag의 데이터를 메인 메모리에서 확인한다.
  - runFlag의 값이 false이므로 while문을 탈출하고, "task 종료"를 출력한다.

### 2-2. 실제 메모리의 접근 방식
- 각 스레드가 runFlag의 값을 사용하면 CPU는 이 값을 효율적으로 처리하기 위해 먼저 runFlag 를 캐시 메모리에 불러온다.
- 그리고 이후에는 캐시 메모리에 있는 runFlag를 사용하게 된다.
  
- 자바 프로그램을 실행하고 main 스레드와 work 스레드는 모두 runFlag의 값을 읽는다.
- CPU는 이 값을 효율적으로 처리하기 위해 먼저 캐시 메모리에 불러온다.
- main 스레드와 work 스레드가 사용하는 runFlag가 각각의 캐시 메모리에 보관된다.
- 프로그램의 시작 시점에는 runFlag를 변경하지 않기 때문에 모든 스레드에서 true의 값을 읽는다.
  - 참고로 runFlag의 초기값은 true이다.
- work 스레드의 경우 while(runFlag[true])가 만족하기 때문에 while문을 계속 반복해서 수행한다.
  - main 스레드는 runFlag 값을 false로 설정한다.
  - 이때 캐시 메모리의 runFlag 값이 false로 설정된다.
  - main 스레드가 runFlag의 값을 변경해도 CPU 코어1이 사용하는 캐시 메모리의 runFlag 값만 false로 변경된다.
  - work 스레드가 사용하는 CPU 코어2의 캐시 메모리의 runFlag 값은 여전히 true이다.
- work 스레드의 경우 while(runFlag[true])가 만족하기 때문에 while문을 계속 반복해서 수행한다.

**※캐시 메모리를 메인 메모리에 반영하거나, 메인 메모리의 변경 내역을 캐시 메모리에 다시 불러오는 것은 언제 발생할까?**
- CPU 설계방식과 실행환경에 따라 다를 수 있따.
- 주로 컨텍스트 스위칭이 될 때, 캐시메모리도 함께 갱신되는데, 이 부분도 환경에 따라 달라질 수 있다.

**※메모리 가시성**
- 멀티 스레드 환경에서 한 스레드가 변경한 값이 다른 스레드에서 언제 보이는지에 대한 문제를 메모리 가시성이라 한다.
- 메모리에 변경한 값이 보이는가, 보이지 않는가의 문제이다.

### 2-3. volatile 사용 예제
- 성능을 약간 포기하는 대신에, 값을 읽거나 쓸 때 모두 메인 메모리에 직접 접근한다.
  
# 3. 자바 메모리 모델
## 3-1. 정의
- 자바 프로그램이 어떻게 메모리에 접근하고 수정할 수 있는지를 규정하며, 특히 멀티 스레드 프로그레밍에서 스레드 간의 상호작용을 정의한다.
- 핵심은 여러 스레드들의 작업 순서를 보장하는 happens-before 관계에 대한 정의이다.

## 3-2. happens-before
- 자바 메모리 모델에서 스레드 간의 작업 순서를 정의하는 개념이다.
- 만약 A 작업이 B 작업보다 happens-before 관계에 있다면, A 작업에서의 모든 메모리에서의 변경 사항은 B 작업에서 볼 수 있다.
- 즉, A 작업에서 변경된 내용은 B 작업이 시작되기 전에 모두 메모리에 반영된다.

  - happens-before 관계는 이름 그대로, 한 동작이 다른 동작보다 먼저 발생함을 보장한다.
  - happens-before 관계는 스레드 간의 메모리 가시성을 보장하는 규칙이다.
  - happens-before 관계가 성립하면, 한 스레드의 작업을 다른 스레드에서 볼 수 있게 된다.
  - 즉, 한 스레드에서 수행한 작업을 다른 스레드가 참조할 때 최신 상태가 보장되는 것이다. 
