# CAS - 동기화와 원자적 연산
- 컴퓨터 과학에서 사용하는 **원자적 연산**의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다.
- 즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다.
- 쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻이다.

- 예시
 ```volatile int i = 0;```
다음과 같은 필드가 있을 때, 다음 연산은 둘로 쪼갤 수 없는 원자적 연산이다.
- ```i= 1;```
- 왜냐하면 이 연산은 다음 단 하나의 순서로 실행되기 때문이다.
1. 오른쪽에 있는 1의 값은 왼쪽의 i 변수에 대입한다.

- 하지만 ```i = i+1;```은 원자적 연산이 아니다.
- 왜냐하면 이 연산은 다음 순서로 나누어 실행되기 때문이다.
1. 오른쪽에 있는 i의 값을 읽는다. i의 값은 10이다.
2. 읽은 10에 1을 더해서 11을 만든다.
3. 더한 11을 왼쪽의 i변수에 대입한다.

원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다.
하지만 원자적 연산이 아닌 경우에는 synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

## 1. 원자적이지 않은 연산을 멀티스레드 환경에서 실행하면?
```
public interface IncrementInteger {
    void increment();

    int get();
}
```
- IncrementInteger는 값을 증가하는 기능을 가진 숫자 기능을 제공하는 인터페이스다.
- increment() : 값을 하나 증가
- get() : 값을 조회

```
public class BasicInteger implements IncrementInteger {

    private int value;

    @Override
    public void increment(){
      value++;
    };

    @Override
    public int get() {
      return value;    
    };
}
```
- increment()를 호출하면 value++ 를 통해서 값을 하나 증가한다.
- value 값은 인스턴스의 필드이기 때문에, 여러 스레드가 공유할 수 있다.
- 이렇게 공유 가능한 자원에 ++와 같은 원자적이지 않은 연산을 사용하면 멀티스레드 상황에 문제가 될 수 있다.

```
public class IncrementThreadMain {

  public static final int THREAD_COUNT = 1000;

  public static void main(String[] args) throws InterruptedException {
    test(new BasicInteger());
  }

  private static void test(IncrementInteger incrementInteger) throws InterruptedException {

    Runnable runnable = new Runnable() {
        @Override
        public void run() {
          incrementInteger.increment();

        }
    };

  List<Thread> threads = new ArrayList<>();
  for(int i=0; i< THREAD_COUNT; i++) {
    Thread thread = new Thread(runnable);
    threads.add(thread);
    thread.start();
  }
  for(Thread thread : threads) { 

  thread.join();
  }  

int result = incrementInteger.get();
}
}
```
# 2. 원자적 연산 - volatile, synchronized
## 1-1. volatile
- volatile 은 여러 CPU 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화되지 않는 문제를 해결한다.
- volatile 을 사용하면 CPU의 캐시 메모리를 무시하고, 메인 메모리를 직접 사용하도록 한다.
- 하지만 이 문제는 캐시 메모리를 사용하지 않고 메인 메모리를 직접 사용해도 여전히 발생하는 문제이다.
- 이 문제는 연산 자체가 나누어져 있기 때문에 발생한다.
- 이렇게 연산 자체가 나누어진 경우에는 synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

## 1-2. synchronized
- synchronized를 통해 안전한 임계 영역을 만들고 value++ 연산을 수행하면, 한 번에 하나의 스레드만 해당 연산을 수행할 수 있다.

## 3. 원자적 연산 - AtomicInteger
- AtomicInteger 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다.
- 특정 값을 증가하거나 감소해야 하는데 여러 스레드가 해당 값을 공유해야 한다면, AtomicInteger를 사용하면 된다.

## 4. 원자적 연산 - 성능 테스트
**BasicInteger**
- 가장 빠르다.
- CPU 캐시를 적극 사용한다.
- 안전한 임계 영역도 없고, volatile도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하는 경우에 효율적이다.

**VolatileInteger**
- volatile을 사용해서 CPU 캐시를 사용하지 않고 메인 메모리를 사용한다.
- 안전한 임계 영역이 없기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하기에는 BasicInteger보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.

**synchronized**
- synchronized를 사용한 안전한 임계 영역이 있기 때문에 멀티스레드 상황에도 안전하게 사용할 수 있다
- MyAtomicInteger보다 성능이 느리다.

**AtomicInteger**
- 멀티스레드 상황에 안전하게 사용할 수 있다.
- 성능도 synchronized, Lock(ReentrantLock)을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.
- 락을 사용하지 않고, 원자적 연산을 만들어낸다.

## 5. CAS 연산 1
### 5-1. 락 기반 방식의 문제점
- 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대해 접근하는 것을 제한한다.
- 락이 걸려있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다.
- 또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요된다.
- 락을 사용하는 방식은 다음과 같이 작동한다.
  1. 락이 있는지 확인한다.
  2. 락을 획득하고 임계 영역에 들어간다.
  3. 작업을 수행한다.
  4. 락을 반납한다.
 
### 5-2. CAS(Compare-And-Swap, Compare-And-Set)
- 락을 걸지 않고 원자적 연산을 수행할 수 있는 방법이다.
- CAS 연산은 락을 완전히 대체하는 것은 아니고, 작은 단위의 일부 영역에 접근할 수 있다.

**compareAndSet(0,1)**
- atomicInteger가 가지고 있는 값이 현재 0이면 이 값을 1로 변경하라는 매우 단순한 메서드이다.
  - 만약 atomicInteger의 값이 현재 0이라면 atomicInteger의 값은 1로 변경된다. 이 경우 true를 반환한다.
  - 만약 atomicInteger의 값이 현재 0이 아니라면 atomicInteger의 값은 변경되지 않는다. 이 경우 false를 반환한다.
- 이 명령어는 2개로 나누어진 명령어이다. 따라서 원자적이지 않은 연산처럼 보인다.
   1. 먼저 메인 메모리에 있는 값을 확인한다.
   2. 해당 값이 기대하는 값(0)이라면 원하는 값(1)로 변경한다.
- 하지만, 이 메서드는 원자적으로 실행된다.

### 5-3. CPU 하드웨어의 지원
- CAS 연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다.
- CPU는 다음 두 과정을 묶어서 하나의 원자적인 명령으로 만들어버린다. 따라서 중간에 다른 스레드가 개입할 수 없다.
  1. x001(예시)의 값을 확인한다.
  2. 읽은 값이 0이면 1로 변경한다.
- CPU는 두 과정을 하나의 원자적인 명령으로 만들기 위해 1번과 2번 사이에 다른 스레드가 x001의 값을 변경하지 못하게 막는다.

## 6. CAS 연산 2
- 어떤 값을 하나 증가하는 value++은 원자적 연산이 아니다.
```i = i + 1;```
1. 오른쪽에 있는 i의 값을 읽는다. i의 초기 값은 0으로 가정한다.
2. 읽은 0에 1을 더해서 1을 만든다.
3. 더한 1을 왼쪽의 i 변수에 대입한다.

- 1번과 3번 연산 사이에 다른 스레드가 i의 값을 변경할 수 있기 때문에, 문제가 될 수 있다.
- 따라서 value++ 연산을 여러 스레드에서 사용한다면, 락을 건 다음에 값을 증가해야 한다.

## 6-1. 락 없이 값을 증가하는 incrementAndGet()
```
private static int incrementAndGet(AtomicInteger atomicInteger) {
    int getValue;
    boolean result;
    do {
      getValue = value 값을 얻어옴;
      result = atomicInteger.compareAndSet(getValue, getValue + 1); // 방금 읽은 value 값이 메모리의 value 값과 같다면 value 값을 하나 증가함.
    } while (!result);
    return getValue + 1;
}
```
## 6-2. 정리
- CAS를 사용하면 락을 사용하지 않지만, 대신에 다른 스레드가 값을 먼저 증가해서 문제가 발생하는 경우 루프를 돌며 재시도를 하는 방식을 사용한다.
- 이 방식은 다음과 같이 동작한다.
  1. 현재 변수의 값을 읽어온다.
  2. 변수의 값을 1 증가시킬 때, 원래 값이 같은지 확인한다. (CAS 사용)
  3. 동일하다면 증가된 값을 변수에 저장하고 종료한다.
  4. 동일하지 않다면 다른 스레드가 값을 중간에 변경한 것이므로, 다시 처음으로 돌아가 위 과정을 반복한다.
- 이 과정에서 스레드 충돌이 발생할 때마다 반복해서 다시 시도하므로, 결과적으로 락 없이 데이터를 안전하게 변경할 수 있다.
- CAS를 사용하는 방식은 충돌이 드물게 발생하는 환경에서는 높은 성능을 발휘할 수 있다.
- 스레드가 락을 획득하기 위해 대기하지 않기 때문에 대기 시간과 오버헤드가 줄어드는 장점이 있다.
- 그러나 충돌이 빈번하게 발생하는 환경에서는 성능에 문제가 될 수 있다.
- 여러 스레드가 자주 동시에 변수의 값을 변경하려고 시도할 때, CAS는 자주 실패하고 재시도해야 하므로 성능 저하가 발생할 수 있다.

## 6-3.  CAS(Compare-And-Swap)와 락(Lock) 방식의 비교
**락(Lock) 방식**
- 비관적(pessimistic) 접근법
- 데이터에 접근하기 전에 항상 락을 획득
- 다른 스레드의 접근을 막음
- "다른 스레드가 방해할 것이다"고 가정

**CAS(Compare-And-Swap) 방식**
- 낙관적(optimistic) 접근법
- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- "대부분의 경우 충돌이 없을 것이다"고 가정

정리하면 충돌이 많이 없는 경우에 CAS 연산이 빠른 것을 확인할 수 있다.
사실 간단한 CPU 연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다.

## 7. CAS 락 구현
- CAS는 단순한 연산 뿐만 아니라, 락을 구현하는데 사용할 수도 있다.
- synchronized, Lock(ReentrantLock) 없이 CAS를 활용해서 락을 구현해보자.
  
