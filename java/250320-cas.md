# CAS - 동기화와 원자적 연산
- 컴퓨터 과학에서 사용하는 **원자적 연산**의 의미는 해당 연산이 더 이상 나눌 수 없는 단위로 수행된다는 것을 의미한다.
- 즉, 원자적 연산은 중단되지 않고, 다른 연산과 간섭 없이 완전히 실행되거나 전혀 실행되지 않는 성질을 가지고 있다.
- 쉽게 이야기해서 멀티스레드 상황에서 다른 스레드의 간섭 없이 안전하게 처리되는 연산이라는 뜻이다.

- 예시
 ```volatile int i = 0;```
다음과 같은 필드가 있을 때, 다음 연산은 둘로 쪼갤 수 없는 원자적 연산이다.
- ```i= 1;```
- 왜냐하면 이 연산은 다음 단 하나의 순서로 실행되기 때문이다.
1. 오른쪽에 있는 1의 값은 왼쪽의 i 변수에 대입한다.

- 하지만 ```i = i+1;```은 원자적 연산이 아니다.
- 왜냐하면 이 연산은 다음 순서로 나누어 실행되기 때문이다.
1. 오른쪽에 있는 i의 값을 읽는다. i의 값은 10이다.
2. 읽은 10에 1을 더해서 11을 만든다.
3. 더한 11을 왼쪽의 i변수에 대입한다.

원자적 연산은 멀티스레드 상황에서 아무런 문제가 발생하지 않는다.
하지만 원자적 연산이 아닌 경우에는 synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

## 1. 원자적이지 않은 연산을 멀티스레드 환경에서 실행하면?
```
public interface IncrementInteger {
    void increment();

    int get();
}
```
- IncrementInteger는 값을 증가하는 기능을 가진 숫자 기능을 제공하는 인터페이스다.
- increment() : 값을 하나 증가
- get() : 값을 조회

```
public class BasicInteger implements IncrementInteger {

    private int value;

    @Override
    public void increment(){
      value++;
    };

    @Override
    public int get() {
      return value;    
    };
}
```
- increment()를 호출하면 value++ 를 통해서 값을 하나 증가한다.
- value 값은 인스턴스의 필드이기 때문에, 여러 스레드가 공유할 수 있다.
- 이렇게 공유 가능한 자원에 ++와 같은 원자적이지 않은 연산을 사용하면 멀티스레드 상황에 문제가 될 수 있다.

```
public class IncrementThreadMain {

  public static final int THREAD_COUNT = 1000;

  public static void main(String[] args) throws InterruptedException {
    test(new BasicInteger());
  }

  private static void test(IncrementInteger incrementInteger) throws InterruptedException {

    Runnable runnable = new Runnable() {
        @Override
        public void run() {
          incrementInteger.increment();

        }
    };

  List<Thread> threads = new ArrayList<>();
  for(int i=0; i< THREAD_COUNT; i++) {
    Thread thread = new Thread(runnable);
    threads.add(thread);
    thread.start();
  }
  for(Thread thread : threads) { 

  thread.join();
  }  

int result = incrementInteger.get();
}
}
```
# 2. 원자적 연산
## 1-1. volatile
- volatile 은 여러 CPU 사이에 발생하는 캐시 메모리와 메인 메모리가 동기화되지 않는 문제를 해결한다.
- volatile 을 사용하면 CPU의 캐시 메모리를 무시하고, 메인 메모리를 직접 사용하도록 한다.
- 하지만 이 문제는 캐시 메모리를 사용하지 않고 메인 메모리를 직접 사용해도 여전히 발생하는 문제이다.
- 이 문제는 연산 자체가 나누어져 있기 때문에 발생한다.
- 이렇게 연산 자체가 나누어진 경우에는 synchronized 블럭이나 Lock 등을 사용해서 안전한 임계 영역을 만들어야 한다.

## 1-2. synchronized
- synchronized를 통해 안전한 임계 영역을 만들고 value++ 연산을 수행하면, 한 번에 하나의 스레드만 해당 연산을 수행할 수 있다.

## 1-3. AtomicInteger
- AtomicInteger 는 멀티스레드 상황에 안전하고 또 다양한 값 증가, 감소 연산을 제공한다.
- 특정 값을 증가하거나 감소해야 하는데 여러 스레드가 해당 값을 공유해야 한다면, AtomicInteger를 사용하면 된다.

## 1-4. 성능 테스트
**BasicInteger**
- 가장 빠르다.
- CPU 캐시를 적극 사용한다.
- 안전한 임계 영역도 없고, volatile도 사용하지 않기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하는 경우에 효율적이다.

**VolatileInteger**
- volatile을 사용해서 CPU 캐시를 사용하지 않고 메인 메모리를 사용한다.
- 안전한 임계 영역이 없기 때문에 멀티스레드 상황에는 사용할 수 없다.
- 단일 스레드가 사용하기에는 BasicInteger보다 느리다. 그리고 멀티스레드 상황에도 안전하지 않다.

**synchronized**
- synchronized를 사용한 안전한 임계 영역이 있기 때문에 멀티스레드 상황에도 안전하게 사용할 수 있다
- MyAtomicInteger보다 성능이 느리다.

**AtomicInteger**
- 멀티스레드 상황에 안전하게 사용할 수 있다.
- 성능도 synchronized, Lock(ReentrantLock)을 사용하는 경우보다 1.5 ~ 2배 정도 빠르다.
- 락을 사용하지 않고, 원자적 연산을 만들어낸다.

## 3. CAS 연산 1
### 3-1. 락 기반 방식의 문제점
- 락은 특정 자원을 보호하기 위해 스레드가 해당 자원에 대해 접근하는 것을 제한한다.
- 락이 걸려있는 동안 다른 스레드들은 해당 자원에 접근할 수 없고, 락이 해제될 때까지 대기해야 한다.
- 또한 락 기반 접근에서는 락을 획득하고 해제하는 데 시간이 소요된다.
- 락을 사용하는 방식은 다음과 같이 작동한다.
  1. 락이 있는지 확인한다.
  2. 락을 획득하고 임계 영역에 들어간다.
  3. 작업을 수행한다.
  4. 락을 반납한다.
 
### 3-2. CAS(Compare-And-Swap, Compare-And-Set)
- 락을 걸지 않고 원자적 연산을 수행할 수 있는 방법이다.
- CAS 연산은 락을 완전히 대체하는 것은 아니고, 작은 단위의 일부 영역에 접근할 수 있다.

**compareAndSet(0,1)**
- atomicInteger가 가지고 있는 값이 현재 0이면 이 값을 1로 변경하라는 매우 단순한 메서드이다.
  - 만약 atomicInteger의 값이 현재 0이라면 atomicInteger의 값은 1로 변경된다. 이 경우 true를 반환한다.
  - 만약 atomicInteger의 값이 현재 0이 아니라면 atomicInteger의 값은 변경되지 않는다. 이 경우 false를 반환한다.
- 이 명령어는 2개로 나누어진 명령어이다. 따라서 원자적이지 않은 연산처럼 보인다.
   1. 먼저 메인 메모리에 있는 값을 확인한다.
   2. 해당 값이 기대하는 값(0)이라면 원하는 값(1)로 변경한다.
- 하지만, 이 메서드는 원자적으로 실행된다.

### 3-3. CPU 하드웨어의 지원
- CAS 연산은 이렇게 원자적이지 않은 두 개의 연산을 CPU 하드웨어 차원에서 특별하게 하나의 원자적인 연산으로 묶어서 제공하는 기능이다.
- CPU는 다음 두 과정을 묶어서 하나의 원자적인 명령으로 만들어버린다. 따라서 중간에 다른 스레드가 개입할 수 없다.
  1. x001(예시)의 값을 확인한다.
  2. 읽은 값이 0이면 1로 변경한다.
- CPU는 두 과정을 하나의 원자적인 명령으로 만들기 위해 1번과 2번 사이에 다른 스레드가 x001의 값을 변경하지 못하게 막는다.

## 4. CAS 연산 2
- 어떤 값을 하나 증가하는 value++은 원자적 연산이 아니다.
```i = i + 1;```
1. 오른쪽에 있는 i의 값을 읽는다. i의 초기 값은 0으로 가정한다.
2. 읽은 0에 1을 더해서 1을 만든다.
3. 더한 1을 왼쪽의 i 변수에 대입한다.

- 1번과 3번 연산 사이에 다른 스레드가 i의 값을 변경할 수 있기 때문에, 문제가 될 수 있다.
- 따라서 value++ 연산을 여러 스레드에서 사용한다면, 락을 건 다음에 값을 증가해야 한다.

## 4-1. 락 없이 값을 증가하는 incrementAndGet()
```
private static int incrementAndGet(AtomicInteger atomicInteger) {
    int getValue;
    boolean result;
    do {
      getValue = value 값을 얻어옴;
      result = atomicInteger.compareAndSet(getValue, getValue + 1); // 방금 읽은 value 값이 메모리의 value 값과 같다면 value 값을 하나 증가함.
    } while (!result);
    return getValue + 1;
}
```
## 4-2. 정리
- CAS를 사용하면 락을 사용하지 않지만, 대신에 다른 스레드가 값을 먼저 증가해서 문제가 발생하는 경우 루프를 돌며 재시도를 하는 방식을 사용한다.
- 이 방식은 다음과 같이 동작한다.
  1. 현재 변수의 값을 읽어온다.
  2. 변수의 값을 1 증가시킬 때, 원래 값이 같은지 확인한다. (CAS 사용)
  3. 동일하다면 증가된 값을 변수에 저장하고 종료한다.
  4. 동일하지 않다면 다른 스레드가 값을 중간에 변경한 것이므로, 다시 처음으로 돌아가 위 과정을 반복한다.
- 이 과정에서 스레드 충돌이 발생할 때마다 반복해서 다시 시도하므로, 결과적으로 락 없이 데이터를 안전하게 변경할 수 있다.
- CAS를 사용하는 방식은 충돌이 드물게 발생하는 환경에서는 높은 성능을 발휘할 수 있다.
- 스레드가 락을 획득하기 위해 대기하지 않기 때문에 대기 시간과 오버헤드가 줄어드는 장점이 있다.
- 그러나 충돌이 빈번하게 발생하는 환경에서는 성능에 문제가 될 수 있다.
- 여러 스레드가 자주 동시에 변수의 값을 변경하려고 시도할 때, CAS는 자주 실패하고 재시도해야 하므로 성능 저하가 발생할 수 있다.

## 4-3.  CAS(Compare-And-Swap)와 락(Lock) 방식의 비교
**락(Lock) 방식**
- 비관적(pessimistic) 접근법
- 데이터에 접근하기 전에 항상 락을 획득
- 다른 스레드의 접근을 막음
- "다른 스레드가 방해할 것이다"고 가정

**CAS(Compare-And-Swap) 방식**
- 낙관적(optimistic) 접근법
- 락을 사용하지 않고 데이터에 바로 접근
- 충돌이 발생하면 그때 재시도
- "대부분의 경우 충돌이 없을 것이다"고 가정

정리하면 충돌이 많이 없는 경우에 CAS 연산이 빠른 것을 확인할 수 있다.
사실 간단한 CPU 연산은 너무 빨리 처리되기 때문에 충돌이 자주 발생하지 않는다.

## 5. CAS 락 구현 1
- CAS는 단순한 연산 뿐만 아니라, 락을 구현하는데 사용할 수도 있다.
- synchronized, Lock(ReentrantLock) 없이 CAS를 활용해서 락을 구현해보자.
  
```
public class SpinLockBad {
  private volatile boolean 락 사용 여부(lock) = false;

  public void lock() {
   //락 획득 시도
   while(true) {
     if(락을 아무도 사용하고 있지 않을 때) { // 1. 락 사용여부 확인
      락 사용 여부 변경(해당 스레드가 락 획득); // 2. 락의 값 변경
      break;
     } else {
      락 획득할 때까지 대기;
    }
  }
  //락 획득 완료
 }
 public void unlock() {
  락 사용 여부 변경(해당 스레드가 락 반납);
 }
}
```
- 스레드가 락을 획득하면 while문을 탈출한다.
- 스레드가 락을 획득하지 못하면 락을 획득할 때까지 while문을 계속 반복 실행한다.

```
public class SpinLockMain {
  public static void main(String[] args) {
    SpinLockBad spinLock = new SpinLockBad();

    Runnable task = new Runnable() {

     @Override
     public void run() {
      spinLock.lock();
      try {
        // 임계 영역 - 비즈니스 로직 실행  
        } finally {
           spinLock.unlock();
        } 
     }
   };

  Thread t1 = new Thread(task, "Thread-1");
  Thread t2 = new Thread(task, "Thread-2");

  t1.start();
  t2.start();
}
}
```

**문제점**
- Thread-1, Thread-2 둘다 락 획득을 완료하고, 비즈니스 로직을 수행한 다음에 락을 반납한다.
- 바로 다음 두 부분이 원자적이지 않다는 문제가 있다.
- 1. 락 사용 여부 확인
  2. 락의 값 변경
 - 이 둘은 한 번에 하나의 스레드만 실행해야 한다.
 - 따라서 synchronized 또는 Lock 을 사용해서 두 코드를 동기화해서 안전한 임계 영역을 만들어야 한다.
 - 또는, CAS 연산을 사용하면 두 연산을 하나로 묶어서 하나의 원자적인 연산으로 처리할 수 있다.
 - 락의 사용 여부를 확인하고, 그 값이 기대하는 값과 같다면 변경하는 것이다.
 - 참고로, 락을 반납하는 연산은 연산이 하나인 원자적인 연산이다.

## 6. CAS 락 구현 2
```
public class SpinLock {
  private volatile AtomicBoolean 락 사용 여부(lock) = new AtomicBoolean(false);

  public void lock() {
   //락 획득 시도
   while(!lock.compareAndSet(false,true)) {
     //락 획득 실패
    }
  //락 획득 완료
 }
 public void unlock() {
  lock.set(false);
  log("락 반납 완료);
 }
}
```
- 스레드가 락을 획득하면 while문을 탈출한다.
- 스레드가 락을 획득하지 못하면 락을 획득할 때까지 while문을 계속 반복 실행한다.

- 락을 획득할 때 매우 중요한 부분이 있다. 바로 다음 두 연산을 하나로 만들어야 한다는 점이다.
- **1. 락 사용 여부 확인**
- **2. 락의 값 변경**

- 락을 획득하기 위해 락의 사용 여부를 확인했을 때 lock의 현재 값이 false일 때만 락의 값을 변경할 수 있다.
- 락의 값이 false인 것을 확인한 시점부터 lock의 값을 true로 변경할 때까지 lock의 값은 반드시 false를 유지해야 한다.
- 중간에 다른 스레드가 lock의 값을 true로 변경하면 안된다. 그러면 여러 스레드가 임계 영역을 통과하는 동시성 문제가 발생한다.

- CAS 연산은 이 두 연산을 하나의 원자적인 연산으로 만들어준다.
```lock.compareAndSet(false, true)```
- **1. 락 사용 여부 확인 : lock의 값이 false이면**
- **2. 락의 값 변경 : lock의 값을 true로 변경해라.**

## 7. CAS 장단점
### 7-1. 장점
- 원자적인 연산은 스레드 입장에서 쪼갤 수 없는 하나의 연산이다. 따라서 여러 스레드가 동시에 실행해도 안전하다.
- 동기화 락을 사용하는 경우 스레드가 락을 획득하지 못하면 BLOCKED, WAITNING 등으로 상태가 변한다.
- CAS를 활용한 락 방식은 단순히 while문을 반복할 뿐이다. 따라서 대기하는 스레드도 RUNNABLE 상태를 유지하면서 가볍고 빠르게 작동할 수 있다.

### 7-2. 단점
- RUNNABLE 상태로 락을 획득할 때까지 while문을 반복한다..
- 따라서, 락을 기다리는 스레드가 CPU를 계속 사용하면서 대기한다.

## 8. 정리
**CAS의 장점**
- 1. 낙관적 동기화 : 락을 걸지 않고도 값을 안전하게 업데이트할 수 있다. CAS는 충돌이 자주 발생하지 않을 것이라고 가정한다. 이는 충돌이 적은 환경에서 높은 성능을 발휘한다.
  2. 락 프리(Lock-Free) : CAS는 락을 사용하지 않기 때문에, 락을 획득하기 위해 대기하는 시간이 없다. 따라서 스레드가 블로킹되지 않으며, 병렬 처리가 더 효율적일 수 있다.

**CAS의 단점**
- 1. 충돌이 빈번한 경우 : 여러 스레드가 동일한 변수에 접근하여 업데이트를 시도할 때 충돌이 발생할 수 있다. 충돌이 발생하면 CAS는 루프를 돌며 재시도해야 하며, 이에 따라 CPU 자원을 계속 소모할 수 있다.
  2. 스핀락과 유사한 오버헤드 : CAS는 충돌 시 반복적인 재시도를 하므로, 이 과정이 반복되면 스핀락과 유사한 성능 저하가 발생할 수 있다.
 
**동기화 락의 장점**
- 1. 충돌 관리 : 락을 사용하면 하나의 스레드만 리소스에 접근할 수 있으므로 충돌이 발생하지 않는다. 여러 스레드가 경쟁할 경우에도 안정적으로 동작한다.
  2. 안정성 : 복잡한 상황에서도 락은 일관성 있는 동작을 보장한다.
  3. 스레드 대기 : 락을 대기하는 스레드는 CPU를 거의 사용하지 않는다.

**동기화 락의 단점**
- 1. 락 획득 대기 시간 : 스레드가 락을 획득하기 위해 대기해야 하므로, 대기 시간이 길어질 수 있다.
  2. 컨텍스트 스위칭 오버헤드 : 락을 사용하면, 락 획득을 대기하는 시점과 또 락을 획득하는 시점에 스레드의 상태가 변경된다.
     이때 컨텍스트 스위칭이 발생할 수 있으며, 이로 인해 오버헤드가 증가할 수 있다.

## 9. 결론
- 일반적으로 동기화 락을 사용하고, 아주 특별한 경우에 한정해서 CAS를 사용해서 최적화해야 한다.
- CAS를 통한 최적화를 할 경우에는, 대기하는 스레드가 CPU 자원을 계속 소모하기 때문에 대기 시간이 아주 짧아야 한다.
- 따라서, 임계 영역이 필요하지만, 연산이 길지 않고 매우 짧게 끝날 때 사용해야 한다.
- 예를 들어 숫자 값의 증가, 자료 구조의 데이터 추가, 삭제와 같이 CPU 사이클이 금방 끝나지만 안전한 임계 영역, 또는 원자적인 연산이 필요한 경우에 사용해야 한다.
- 반면에, 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것처럼 오래 기다리는 작업에는 동기화 락을 사용해야 한다.

## 10. 실무 관점
- 실무 관점에서 보면 대부분의 애플리케이션들은 공유 자원을 사용할 때, 충돌하지 않을 가능성이 훨씬 높다.
- CPU가 1초에 얼마나 많은 연산을 처리하는지 생각해보면, 백만건 중에 충돌이 나는 경우는 몇십 건 이하일 것이다.
- 따라서 주문 수 증가와 같은 단순한 연산의 경우, CAS처럼 낙관적인 방식이 더 나은 성능을 보인다.
- 주문 수 증가는 나노 초 단위로 발생하는 연산이다.
- 반면에 데이터베이스를 기다린다거나, 다른 서버의 요청을 기다리는 것 처럼 수 밀리초 이상의 시간이 걸리는 작업이라면 동기화 락을 사용하거나 스레드가 대기하는 방식이 더 효과적이다
