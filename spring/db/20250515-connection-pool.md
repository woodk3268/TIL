# 커넥션 풀과 DataSource 이해

---

## ✅ 학습 주제

* JDBC에서 커넥션 획득 비용과 이를 해결하는 커넥션 풀 개념 이해
* `DataSource`를 통한 커넥션 획득 방식 추상화 및 적용 방법 학습
* 실무에서 사용하는 커넥션 풀 라이브러리(HikariCP) 사용법

---

## 🧩 핵심 개념 요약

| 개념                      | 설명                                             |
| ----------------------- | ---------------------------------------------- |
| 커넥션 풀                   | 커넥션을 미리 생성해두고, 재사용 가능한 구조. 응답 속도 향상과 자원 효율성 확보 |
| DataSource              | 커넥션 획득 방식을 추상화한 인터페이스. 다양한 커넥션 획득 전략을 하나로 통합   |
| DriverManagerDataSource | DataSource 구현체. 매번 새 커넥션 생성 (풀링 X)             |
| HikariDataSource        | 고성능 커넥션 풀 구현체. 스프링 부트 2.0+ 기본 제공               |

---

## ⚙️ 커넥션 풀 도입 이유

* 커넥션 획득에는 TCP/IP 연결, 인증, DB 세션 생성 등 많은 비용이 발생
* 사용자 요청마다 새 커넥션 생성 시 성능 저하
* 커넥션을 미리 생성해두고, 필요할 때 빌려쓰고 반납하는 **풀(Pool)** 구조가 해결책

---

## 🛠️ 커넥션 풀 적용 흐름

1. 앱 시작 시 풀 초기화 → 커넥션 미리 확보 (ex. 10개)
2. 요청 발생 시 풀에서 커넥션 빌려서 사용
3. 사용 후 종료가 아닌 **풀에 반환**
4. 성능 개선 + DB 보호 (커넥션 수 제한)

---

## 🛠️ DataSource 추상화 흐름

* 기존 JDBC: `DriverManager.getConnection(url, id, pw)`
  → 매번 파라미터 필요, 직접 구현체 의존

* DataSource 도입:

  ```java
  DataSource ds = new HikariDataSource();
  Connection con = ds.getConnection(); // 재사용 가능
  ```

  → 설정과 사용 분리, 추상화로 DI 적용 가능

---

## ✅ 실무에서의 적용: HikariCP

```java
HikariDataSource ds = new HikariDataSource();
ds.setJdbcUrl(URL);
ds.setUsername(USERNAME);
ds.setPassword(PASSWORD);
ds.setMaximumPoolSize(10);
ds.setPoolName("MyPool");
```

* 내부적으로 `HikariProxyConnection` 사용
* 풀의 커넥션은 별도 쓰레드에서 초기화
* `conn0`, `conn1`, … 등 이름으로 실제 커넥션 추적 가능

---

## 📄 장점 요약

| 항목   | 설명                                     |
| ---- | -------------------------------------- |
| 성능   | 커넥션 생성 시간 제거 → 빠른 응답                   |
| 유지보수 | DataSource 사용으로 코드 변경 최소화              |
| 유연성  | 커넥션 풀 구현체 교체가 쉬움 (ex. DBCP → HikariCP) |
| 안정성  | 커넥션 수 제한으로 DB 과부하 방지                   |

---
## Q&A
💡 **DB 작업마다 커넥션이 필요한가? 아니면 한 번 연결해서 계속 쓰는가?**

---

## ✅ 기본 원칙: DB 작업마다 커넥션 필요

* JDBC에서 **모든 SQL 실행은 커넥션(Connection)** 객체를 통해 수행된다.
* 따라서 **SELECT, INSERT, UPDATE, DELETE 할 때마다 커넥션이 있어야 한다.**
* 커넥션이 없으면 Statement, PreparedStatement도 만들 수 없고, 실행도 불가능하다.

📌 즉, \*\*"커넥션은 모든 DB 작업의 시작점"\*\*.

---

## ✅ 그럼 한 번 연결한 커넥션을 계속 쓰면 안 되는가?

**직접 재사용은 위험하고, 대신 “커넥션 풀(Pool)”이 해결책**

### ❌ 커넥션을 직접 재사용하면 생기는 문제

| 문제      | 설명                                                  |
| ------- | --------------------------------------------------- |
| 동시성     | 여러 사용자가 동시에 요청할 때 커넥션 충돌                            |
| 트랜잭션 충돌 | 이전 작업의 상태(autocommit, isolation level 등)가 남아있을 수 있음 |
| 리소스 누수  | 사용자가 커넥션을 닫지 않으면 DB 연결이 해제되지 않음                     |

---

## ✅ 실무 방식: 커넥션 풀을 사용해 “재사용은 하되, 격리 보장”

> 커넥션 풀은 **미리 커넥션을 만들어두고**, 요청마다 **하나씩 빌려주고 반납받는 구조**.

* 개발자는 매번 `DataSource.getConnection()`을 호출하지만
* 실제로는 새로운 커넥션이 아니라 **풀에서 미리 생성된 커넥션을 가져옴**
* 사용 후에는 `conn.close()` 하면 **진짜로 종료되는 게 아니라, 풀에 반환됨**

📌 이 방식은 재사용하면서도 **"각 요청은 독립된 커넥션처럼 안전하게"** 처리된다.


---

## 🧠 인사이트

* JDBC 실무 코드에선 `DataSource` 주입을 표준으로 사용
* 커넥션 획득은 성능과 보안 모두에 영향을 주는 민감한 영역
* 스프링 부트는 HikariCP를 기본 채택함 → 별도 설정 없이도 적용 가능

