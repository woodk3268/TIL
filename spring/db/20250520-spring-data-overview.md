#  데이터 접근 기술 - 시작

---

## ✅ 학습 주제

* 다양한 **데이터 접근 기술**의 분류와 특징 이해
* 메모리 저장소에서 데이터베이스로 점진적 전환
* 스프링 부트 환경에서 데이터 접근 구조 설계 방법
* 스프링 프로필 설정 및 테스트 구성 방식

---

## 🧩 핵심 개념 요약

| 분류             | 기술                                        | 특징                      |
| -------------- | ----------------------------------------- | ----------------------- |
| **SQL Mapper** | JdbcTemplate, MyBatis                     | SQL 직접 작성, 중복 제거, 매핑 편의 |
| **ORM**        | JPA(Hibernate), Spring Data JPA, Querydsl | 객체 중심 데이터 조작, SQL 자동 생성 |

| 항목                                            | 설명                                     |
| --------------------------------------------- | -------------------------------------- |
| `MemoryItemRepository`                        | 메모리에 데이터를 저장하는 기본 리포지토리                |
| `ItemRepository`                              | 다양한 저장 방식(JDBC, JPA 등)으로 구현하기 위한 인터페이스 |
| `ItemService`                                 | 리포지토리를 감싸는 서비스 계층 인터페이스                |
| `ItemServiceV1`                               | `ItemRepository` 구현체를 주입받아 사용하는 구현체    |
| `ItemController`                              | CRUD 처리를 담당하는 웹 컨트롤러                   |
| `MemoryConfig`                                | 메모리 저장소를 빈으로 등록하는 Java Config          |
| `TestDataInit`                                | 애플리케이션 실행 시 테스트 데이터 초기화 담당 클래스         |
| `@Profile`                                    | 환경(local, test 등)에 따라 빈 등록 여부 제어       |
| `@EventListener(ApplicationReadyEvent.class)` | 스프링 컨테이너 초기화 완료 후 실행되는 메서드             |

---

## 🛠️ 프로젝트 구성 및 설정 요약

### 1. 프로젝트 구조

* `domain`: Item 객체 정의
* `repository`: 저장소 인터페이스 및 구현체
* `service`: 비즈니스 로직 계층
* `web`: 컨트롤러 계층
* `config`: 스프링 설정 (빈 등록, 프로필 등)

### 2. 설정 정보

* Java 11 사용
* build.gradle에서 Thymeleaf, Web, Lombok, Test 의존성 설정
* `application.properties`:

  ```properties
  spring.profiles.active=local
  ```

### 3. 테스트 환경

* 테스트 전후 `@AfterEach`로 메모리 초기화
* `@SpringBootTest`로 통합 테스트 진행

---

## 📦 테이블 생성 예시 (H2 기준)

```sql
create table item (
    id        bigint generated by default as identity,
    item_name varchar(10),
    price     integer,
    quantity  integer,
    primary key (id)
);
```

---

## 💡 인사이트

* **SQL Mapper**는 SQL을 명시적으로 작성해야 하므로 복잡한 쿼리에 유리함
* **ORM**은 객체 중심 접근으로 생산성과 유지보수성이 높음
* \*\*대리 키(surrogate key)\*\*를 PK로 사용하는 것이 장기적인 설계에 더 유리
* **스프링 프로필**을 활용하면 개발/운영/테스트 환경을 유연하게 분리 가능

---

## 🚀 진행 방식 요약

1. 메모리 저장소로 구현된 완성 프로젝트 준비
2. 점진적으로 JdbcTemplate → MyBatis → JPA → Spring Data JPA → Querydsl 적용
3. 각 기술의 특징, 장단점을 실습과 비교를 통해 이해


