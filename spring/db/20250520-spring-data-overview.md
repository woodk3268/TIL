#  데이터 접근 기술 - 시작

---

## ✅ 학습 주제

* 다양한 **데이터 접근 기술**의 분류와 특징 이해
* 메모리 저장소에서 데이터베이스로 점진적 전환
* 스프링 부트 환경에서 데이터 접근 구조 설계 방법
* 스프링 프로필 설정 및 테스트 구성 방식

---

## 🧩 핵심 개념 요약

| 분류             | 기술                                        | 특징                      |
| -------------- | ----------------------------------------- | ----------------------- |
| **SQL Mapper** | JdbcTemplate, MyBatis                     | SQL 직접 작성, 중복 제거, 매핑 편의 |
| **ORM**        | JPA(Hibernate), Spring Data JPA, Querydsl | 객체 중심 데이터 조작, SQL 자동 생성 |

| 항목                                            | 설명                                     |
| --------------------------------------------- | -------------------------------------- |
| `MemoryItemRepository`                        | 메모리에 데이터를 저장하는 기본 리포지토리                |
| `ItemRepository`                              | 다양한 저장 방식(JDBC, JPA 등)으로 구현하기 위한 인터페이스 |
| `ItemService`                                 | 리포지토리를 감싸는 서비스 계층 인터페이스                |
| `ItemServiceV1`                               | `ItemRepository` 구현체를 주입받아 사용하는 구현체    |
| `ItemController`                              | CRUD 처리를 담당하는 웹 컨트롤러                   |
| `MemoryConfig`                                | 메모리 저장소를 빈으로 등록하는 Java Config          |
| `TestDataInit`                                | 애플리케이션 실행 시 테스트 데이터 초기화 담당 클래스         |
| `@Profile`                                    | 환경(local, test 등)에 따라 빈 등록 여부 제어       |
| `@EventListener(ApplicationReadyEvent.class)` | 스프링 컨테이너 초기화 완료 후 실행되는 메서드             |

---

## 🛠️ 프로젝트 구성 및 설정 요약

### 1. 프로젝트 구조

* `domain`: Item 객체 정의
* `repository`: 저장소 인터페이스 및 구현체
* `service`: 비즈니스 로직 계층
* `web`: 컨트롤러 계층
* `config`: 스프링 설정 (빈 등록, 프로필 등)

### 2. 설정 정보

* Java 11 사용
* build.gradle에서 Thymeleaf, Web, Lombok, Test 의존성 설정
* `application.properties`:

  ```properties
  spring.profiles.active=local
  ```

### 3. 테스트 환경

* 테스트 전후 `@AfterEach`로 메모리 초기화
* `@SpringBootTest`로 통합 테스트 진행

---

## 📦 테이블 생성 예시 (H2 기준)

```sql
create table item (
    id        bigint generated by default as identity,
    item_name varchar(10),
    price     integer,
    quantity  integer,
    primary key (id)
);
```

---

## 💡 인사이트

* **SQL Mapper**는 SQL을 명시적으로 작성해야 하므로 복잡한 쿼리에 유리함
* **ORM**은 객체 중심 접근으로 생산성과 유지보수성이 높음
* \*\*대리 키(surrogate key)\*\*를 PK로 사용하는 것이 장기적인 설계에 더 유리
* **스프링 프로필**을 활용하면 개발/운영/테스트 환경을 유연하게 분리 가능

---

## 🚀 진행 방식 요약

1. 메모리 저장소로 구현된 완성 프로젝트 준비
2. 점진적으로 JdbcTemplate → MyBatis → JPA → Spring Data JPA → Querydsl 적용
3. 각 기술의 특징, 장단점을 실습과 비교를 통해 이해

---

##  Spring AOP와 `@PostConstruct` vs `@EventListener(ApplicationReadyEvent.class)`

### ✅ AOP란?

* AOP(Aspect-Oriented Programming)는 \*\*공통 관심사(Cross-Cutting Concerns)\*\*를 비즈니스 로직과 분리하여 모듈화하는 기법이다.
* 대표적인 공통 관심사 예:

  * 트랜잭션 처리 (`@Transactional`)
  * 로깅
  * 보안
  * 예외 처리
  * 캐싱 등
* **Spring AOP**는 프록시 기반으로 AOP를 제공하며, 런타임에 프록시 객체를 만들어 기능을 삽입한다.

---

### ✅ `@PostConstruct` vs `@EventListener(ApplicationReadyEvent.class)`

| 항목      | `@PostConstruct`           | `@EventListener(ApplicationReadyEvent.class)` |
| ------- | -------------------------- | --------------------------------------------- |
| 호출 시점   | 빈 초기화 직후                   | 스프링 컨테이너 완전 초기화 후                             |
| 트랜잭션 처리 | `@Transactional` 미적용될 수 있음 | `@Transactional` 정상 적용됨                       |
| 사용 목적   | 간단한 설정값 초기화                | DB 저장 등 AOP가 필요한 초기화                          |
| 주의 사항   | AOP 미적용 상태에서 실행될 수 있음      | AOP 적용 완료 상태에서 실행됨                            |

---

### ✅ 정리

* `@PostConstruct`는 **간단한 초기화 로직**에 적합.
* `@EventListener(ApplicationReadyEvent.class)`는 **AOP 기반 기능(@Transactional 등)이 필요한 초기화 로직**에 적합.
* **스프링 컨테이너가 완전히 초기화된 이후 안전하게 실행되길 원한다면 `ApplicationReadyEvent`를 사용하는 것이 좋다.**

---

필요하다면 코드 예제나 참고 링크도 함께 정리해드릴 수 있어요!


