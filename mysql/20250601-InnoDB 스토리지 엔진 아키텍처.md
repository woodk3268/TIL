# 📘 InnoDB 스토리지 엔진 아키텍처

---

## ✅ 학습 주제

* InnoDB의 클러스터 인덱스 및 테이블 구조
* MVCC와 Undo/Redo 로그의 동작 방식
* 자동 데드락 감지와 장애 복구 메커니즘
* 버퍼 풀, 플러시 정책, LRU 리스트 구조 이해
* 버퍼 풀 상태 백업 및 복구 방법

---

## 🧩 핵심 개념 요약

| 개념                          | 설명                                                       |
| --------------------------- | -------------------------------------------------------- |
| **클러스터 인덱스**                | 프라이머리 키 기준으로 레코드를 정렬해 저장하는 인덱스. InnoDB 테이블 자체가 클러스터 인덱스. |
| **보조 인덱스**                  | 프라이머리 키를 포함하여 저장되며, 클러스터 인덱스를 따라가야 실제 데이터를 조회 가능.        |
| **MVCC**                    | 트랜잭션 격리 수준에서의 비잠금 읽기 지원. Undo 로그를 이용해 일관된 스냅샷 생성.        |
| **Undo 로그**                 | 이전 버전 데이터를 보관. 롤백 또는 스냅샷 읽기 시 사용.                        |
| **Redo 로그**                 | 변경 작업을 물리적으로 기록. 장애 발생 시 데이터 복구에 사용.                     |
| **Write-Ahead Logging**     | 데이터 변경 전, 로그를 먼저 기록하여 장애 복구 시 활용.                        |
| **자동 데드락 감지**               | 백그라운드 스레드가 주기적으로 잠금 대기 그래프를 분석하여 데드락 탐지 및 트랜잭션 중단.       |
| **자동 장애 복구**                | 재시작 시 redo 로그를 적용하여 커밋된 작업 복원. undo 로그로 미커밋 작업은 무효화.     |
| **버퍼 풀**                    | 자주 사용하는 페이지를 메모리에 보관하여 디스크 I/O 최소화.                      |
| **LRU 리스트**                 | 최근 사용 여부 기준으로 페이지를 정렬. 오래된 페이지는 제거 대상.                   |
| **Flush List**              | Dirty Page를 변경 시점(LSN 기준)으로 정렬한 리스트.                     |
| **Buffer Pool Flush**       | Dirty Page를 디스크로 반영하는 전체 작업.                             |
| **Flush List Flush**        | Flush 리스트에 있는 페이지를 LSN 순으로 디스크에 반영.                      |
| **LRU 리스트 Flush**           | LRU 리스트의 뒤쪽 페이지가 Dirty 상태일 경우 디스크에 먼저 반영 후 제거.           |
| **Buffer Pool Dump & Load** | 서버 종료 시 버퍼 상태 저장 후 재시작 시 자동 복구 가능 (`ib_buffer_pool`).    |

---

## 🔄 InnoDB 아키텍처 흐름 요약

```
1. 트랜잭션 시작 → 페이지 수정 → Undo 로그 생성 → Redo 로그 기록
2. 커밋 시 → Redo 로그를 먼저 기록 (WAL) → Buffer Pool의 Dirty Page는 나중에 flush
3. 서버 재시작 시 → Redo 로그 기반 복구 → Undo 로그로 롤백
```

---

## 🧠 버퍼 풀과 플러시 전략

| 전략             | 설명                                                                                   |
| -------------- | ------------------------------------------------------------------------------------ |
| **LRU 리스트**    | 자주 사용되지 않은 페이지를 뒤쪽으로 밀어냄                                                             |
| **Flush List** | Dirty Page들을 LSN 순으로 정렬하여 flush 대상 관리                                                |
| **Flush 방식**   | 수동 또는 자동, LRU 기반, Flush 리스트 기반, 강제 flush 가능                                          |
| **버퍼풀 덤프/로드**  | `innodb_buffer_pool_dump_at_shutdown`, `innodb_buffer_pool_load_at_startup` 옵션 사용 가능 |

---

## 🔍 실습용 쿼리 예시

```sql
-- 현재 버퍼 풀에 있는 테이블별 페이지 수 확인
SELECT TABLE_NAME, COUNT(*) AS page_count
FROM INFORMATION_SCHEMA.INNODB_BUFFER_POOL_PAGES
GROUP BY TABLE_NAME
ORDER BY page_count DESC;

-- 현재 InnoDB 엔진 상태 확인
SHOW ENGINE INNODB STATUS\G

-- 버퍼 풀 상태 덤프 & 로드
SET GLOBAL innodb_buffer_pool_dump_now = ON;
SET GLOBAL innodb_buffer_pool_load_now = ON;
```

---

## 💡 인사이트

* InnoDB는 높은 동시성과 장애 복구를 위해 **MVCC, Redo/Undo 로그**, **Buffer Pool** 등의 구조를 조합해 설계되어 있음.
* **Flush 전략의 이해**는 성능 튜닝에서 핵심이며, 특히 LRU와 Flush 리스트의 차이를 정확히 아는 것이 중요함.
* 클러스터 인덱스 기반 저장 방식은 쿼리 성능 향상에 이점을 주지만, 보조 인덱스 접근 시 프라이머리 키가 반드시 포함된다는 점을 고려해야 함.
* **Redo는 다시 실행, Undo는 되돌리기**라는 원칙은 트랜잭션의 안정성과 복구 전략을 이해하는 핵심 포인트.

