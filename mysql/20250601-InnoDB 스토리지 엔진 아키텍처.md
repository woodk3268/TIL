# 📘 InnoDB 스토리지 엔진 아키텍처

---

## 📌 1. 클러스터 인덱스란?

### ✅ 개념

* InnoDB는 테이블 데이터를 B+Tree 형태로 저장하며, 이 B+Tree 자체가 **프라이머리 키 기반 인덱스 구조**.
* 그래서 InnoDB 테이블은 **테이블 = 클러스터 인덱스**라는 말이 성립함.

### ✅ 특징

* 레코드가 **PK 순으로 정렬**되어 저장됨 → 범위 조회에 유리
* 세컨더리 인덱스는 실제 데이터에 접근하기 위해 **PK 값을 저장하고 다시 클러스터 인덱스를 탐색**함 (index lookup 비용 발생)

### 📎 예시

```sql
CREATE TABLE user (
  id INT PRIMARY KEY,
  name VARCHAR(50)
);
-- id가 클러스터 인덱스가 되어, 테이블 자체가 이 인덱스 구조로 정렬됨
```

---

## 📌 2. 인덱스 종류와 클러스터 인덱스의 관계

| 인덱스 종류   | 설명            | 클러스터 인덱스 연관                    |
| -------- | ------------- | ------------------------------ |
| 클러스터 인덱스 | PK 기반, 테이블 자체 | 테이블 = 클러스터 인덱스                 |
| 세컨더리 인덱스 | 보조 인덱스        | 리프 노드에 PK를 저장하고, PK로 다시 테이블 접근 |

### 💡 핵심 차이

세컨더리 인덱스에서 데이터를 읽으려면 →
인덱스 → PK → 클러스터 인덱스 탐색(= 테이블) → 실제 레코드

---

## 📌 3. MVCC (Multi-Version Concurrency Control)

### ✅ 목적

* 트랜잭션 간 충돌 없이 읽기/쓰기 동시성 제공
* \*\*잠금 없이 일관된 읽기(Consistent Read)\*\*를 가능하게 함

### ✅ 동작 방식

* 레코드의 숨은 컬럼에 `trx_id`, `roll_pointer` 등 메타데이터가 저장됨
* Undo 로그를 이용해 **트랜잭션 시작 시점에 일치하는 데이터 버전**을 보여줌

---

## 📌 4. Undo / Redo 로그

| 로그 종류   | 역할              | 저장 위치                     | 예시                |
| ------- | --------------- | ------------------------- | ----------------- |
| Undo 로그 | 롤백용, MVCC 읽기 지원 | 시스템 테이블 스페이스              | UPDATE 전에 기존 값 저장 |
| Redo 로그 | 장애 복구용          | 별도 Redo 파일 (ib\_logfileN) | UPDATE 후 변경 내용 저장 |

### 🚨 왜 둘 다 필요한가?

* **Undo 로그** 없으면 롤백, 일관된 읽기 불가능
* **Redo 로그** 없으면 시스템 장애 시 복구 불가능

---

## 📌 5. Write-Ahead Logging (WAL)

### ✅ 개념

* 데이터를 실제 데이터 파일에 쓰기 전에, 먼저 Redo 로그에 기록
* 이유: 장애 복구 시 로그만으로 데이터 복원 가능

### 🔁 흐름

```text
트랜잭션 실행 → Redo 로그 쓰기 → Buffer Pool 수정 → (나중에) 디스크 반영
```

---

## 📌 6. Buffer Pool

### ✅ 역할

* 자주 쓰이는 테이블/인덱스 페이지(16KB)를 메모리에 캐싱
* **디스크 접근 최소화**로 성능 대폭 향상

### ✅ 구성

* Dirty Page 리스트 (수정된 후 아직 flush되지 않은 페이지)
* LRU 리스트 (오랫동안 사용되지 않은 페이지 제거)
* Flush 리스트 (flush 대상 우선순위 리스트)

### 📎 예시

```bash
SHOW ENGINE INNODB STATUS;
-- Buffer Pool 상태 확인 가능
```

---

## 📌 7. LRU 리스트 & 페이지 플러시

| 항목                 | 설명                           |
| ------------------ | ---------------------------- |
| LRU 리스트            | 최근 사용되지 않은 페이지를 제거 (공간 확보)   |
| Flush 리스트          | 디스크로 내보내야 할 Dirty Page 목록    |
| Doublewrite Buffer | 중간 버퍼 → 실제 테이블 스페이스로 안전하게 쓰기 |

### 🔁 플러시 흐름

```text
Dirty Page 발생 → Flush 리스트 등록 → 일정 조건 시 디스크 기록 (flush)
```

---

## 📌 8. I/O 스케줄링 & 캐시

### ✅ I/O 스케줄링

* 디스크 접근 순서를 최적화해 성능 향상
* 예: SSTF, SCAN 알고리즘

### ✅ 캐시의 종류

* InnoDB Buffer Pool
* OS 페이지 캐시
* 디스크 컨트롤러 내장 캐시

### 📎 비유

* 캐시는 "자주 쓰는 물건을 책상 위에 올려놓는 것"
* 스케줄링은 "택배를 동선 따라 배달하는 것"

---

## 📌 9. 디스크 I/O는 페이지 단위

### ✅ 이유

* 디스크는 **특정 바이트만 수정할 수 없고, 페이지 전체(보통 16KB)를 읽고 써야 함**
* 효율을 위해 페이지 단위로 작업

### ✅ 예시

* 이름 하나 바꿔도 → 해당 페이지 전체를 수정하고 flush

---

## 📌 10. 자동 데드락 감지

* InnoDB는 잠금 대기 그래프를 실시간으로 확인
* 순환 대기 발견 시 → 오래 걸릴 트랜잭션을 강제로 죽이고 에러 반환

---

## 📌 11. 장애 복구 시 흐름

```text
1. Redo 로그 재적용 (물리적 복구)
2. Undo 로그 롤백 (논리적 복구)
```

* 트랜잭션은 커밋 전이라면 “없던 일로 간주”
* 이를 통해 ACID의 **Atomicity** 보장

---

## 🔍 공부 중 생긴 질문과 해소 흐름

| 질문                        | 요점 정리                           |
| ------------------------- | ------------------------------- |
| 클러스터 인덱스가 테이블 자체라는 건?     | 테이블이 PK 정렬된 인덱스 구조로 저장되기 때문     |
| Undo/Redo 로그가 왜 함께 필요한가?  | MVCC·Rollback은 Undo, 장애복구는 Redo |
| Buffer Pool에만 먼저 반영하는 이유? | 속도와 안정성을 동시에 얻기 위해              |
| 페이지 단위 쓰기?                | 디스크 구조상 부분 수정 불가, 전체 쓰기 필요      |
| Redo 로그는 느리지 않아?          | 순차 기록이라 빠름, Write-Ahead 구조 덕분   |

---

## 🧩 인사이트 요약

* InnoDB는 성능과 무결성 간 **균형 설계**의 대표 사례
* Redo + Undo + Buffer Pool의 삼각 구조가 모든 I/O와 트랜잭션의 기반
* 페이지 단위 처리 개념은 MVCC, 로그 구조, 플러시 전략과 긴밀히 연결됨


