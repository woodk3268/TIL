# 📘 스토리지 엔진, 메모리 구조, 플러그인 vs 컴포넌트

---

## ✅ 학습 주제

* MySQL의 로컬 메모리 / 세션 메모리 구조
* 스토리지 엔진 개념과 플러그인 구조
* 플러그인 아키텍처의 한계 및 컴포넌트 아키텍처로의 전환 배경
* 플러그인 간 통신 불가 원인과 설계 철학

---

## 🧩 핵심 개념 요약

| 개념                         | 설명                                                             |
| -------------------------- | -------------------------------------------------------------- |
| **세션 메모리(Session Memory)** | 커넥션 단위로 할당되는 메모리 공간 (`sort_buffer_size`, `join_buffer_size` 등) |
| **로컬 메모리(Local Memory)**   | 쿼리 실행 중 임시로 사용되는 메모리, 대부분 세션 메모리 안에서 사용됨                       |
| **스토리지 엔진**                | 데이터를 디스크/메모리에 저장하는 방식 정의 (InnoDB, MyISAM, MEMORY 등)            |
| **플러그인 아키텍처**              | MySQL에 기능을 끼워넣듯 추가하는 구조. 독립적인 모듈로 서버와만 인터페이스함                  |
| **컴포넌트 아키텍처**              | MySQL 8.0부터 도입. 인터페이스 기반 설계로 컴포넌트 간 의존성과 재사용을 허용               |

---

## 🛠️ MySQL 메모리 구조

| 메모리 종류  | 설명                                  | 할당 단위    |
| ------- | ----------------------------------- | -------- |
| 글로벌 메모리 | 서버 전체가 공유 (InnoDB 버퍼 풀, 리두 로그 버퍼 등) | 서버 전체    |
| 세션 메모리  | 커넥션 단위로 정렬/조인 등 작업에 사용              | 커넥션      |
| 로컬 메모리  | 쿼리 실행 중 잠깐 사용되는 임시 메모리              | 쿼리 실행 단위 |

### 📌 정렬/조인/네트워크 관련 주요 버퍼

| 버퍼 종류      | 사용 상황                   | 설정 변수                                     |
| ---------- | ----------------------- | ----------------------------------------- |
| 정렬 버퍼      | `ORDER BY`, `GROUP BY`  | `sort_buffer_size`                        |
| 조인 버퍼      | 인덱스 없는 Nested Loop Join | `join_buffer_size`                        |
| 바이너리 로그 캐시 | 트랜잭션 로그 임시 저장           | `binlog_cache_size`                       |
| 네트워크 버퍼    | 클라이언트와 데이터 송수신          | `net_buffer_length`, `max_allowed_packet` |

---

## 🏗️ 플러그인 아키텍처 vs 컴포넌트 아키텍처

| 항목      | 플러그인 아키텍처                   | 컴포넌트 아키텍처                |
| ------- | --------------------------- | ------------------------ |
| 도입 시점   | MySQL 5.1                   | MySQL 8.0                |
| 구조      | 독립적인 함수/모듈 단위               | 인터페이스 기반 모듈 단위           |
| 서버와의 관계 | 서버와만 인터페이스                  | 다른 컴포넌트와도 의존성/재사용 가능     |
| 단점      | 플러그인 간 통신 불가, 코드 중복, 의존성 없음 | -                        |
| 장점      | 로딩 단순, 가볍고 빠름               | 구조적 모듈화, 유지보수 쉬움, 재사용 가능 |

---

## 🔍 플러그인 관련 Q\&A 요약

| 질문                  | 핵심 요약                                         |
| ------------------- | --------------------------------------------- |
| 왜 플러그인은 서로 통신 못함?   | 단일 서버 API 기반 구조이기 때문. 다른 플러그인을 인식할 구조가 없음     |
| 왜 서버 함수/변수를 직접 호출함? | 서버 프로세스 내에서 `dlopen()` 방식으로 로드되기 때문에 심볼 접근 가능 |
| 왜 상호 의존 불가능?        | 플러그인 선언 구조에 의존성 표현/주입 체계가 존재하지 않음             |
| 왜 독립성 원칙이 있었을까?     | 안정성, 충돌 방지, 운영 단순화, 초기 오픈소스 전략 때문             |

---

## 💡 인사이트

* 세션 메모리와 로컬 메모리는 쿼리 실행 관점에서는 같게 보일 수 있지만, 튜닝과 분석에서는 구분해서 이해하는 것이 유리하다.
* 스토리지 엔진에 따라 MySQL의 메모리 구조와 캐시 전략이 달라지므로, 목적에 따라 적절한 엔진을 선택해야 한다.
* 플러그인은 단순하지만, 유연성이 떨어지기 때문에 복잡한 기능 구현에는 한계가 있다.
* 컴포넌트 아키텍처는 명시적 의존성, 인터페이스 기반 설계, 재사용 가능성을 통해 유지보수와 확장성을 크게 향상시킨다.

