# ✅ InnoDB 핵심 아키텍처 학습 정리

---

## 📘 학습 주제

* Undo 로그와 트랜잭션 롤백 메커니즘
* Change Buffer(변경 버퍼)의 동작 원리
* Redo 로그 및 로그 버퍼의 역할
* 트랜잭션 커밋과 장애 복구 처리 방식
* innodb\_flush\_log\_at\_trx\_commit 설정의 의미
* 커밋 직후 장애 발생 시 실제 처리 흐름

---

## 🧩 핵심 개념 요약

| 개념                                  | 설명                                                       |
| ----------------------------------- | -------------------------------------------------------- |
| Undo 로그                             | 변경 전 데이터를 보관해 트랜잭션 롤백 및 MVCC를 지원하는 구조                    |
| 롤백 세그먼트                             | Undo 로그를 관리하는 단위. 세그먼트 안에 여러 슬롯 존재                       |
| Undo 슬롯                             | 트랜잭션 하나가 점유하는 공간. 하나의 슬롯 안에는 여러 명령문 가능                   |
| Change Buffer                       | 보조 인덱스에 대한 변경 요청을 디스크 대신 버퍼에 기록해 성능 최적화                  |
| Redo 로그                             | 변경된 내용을 재현할 수 있는 물리적 로그. 장애 발생 시 복구에 사용됨                 |
| 로그 버퍼                               | 메모리 내 임시 저장소. 커밋 전까지 Redo 로그가 여기에 저장됨                    |
| 데이터 파일                              | 실제 데이터(테이블, 인덱스 등)를 저장하는 공간 (`.ibd`, 시스템 테이블스페이스)        |
| 로그 파일                               | Redo 로그가 저장되는 실제 디스크 파일 (`ib_logfile0`, `ib_logfile1` 등) |
| 커밋 마커                               | Redo 로그에 기록되는 "트랜잭션 커밋 완료"의 증거                           |
| innodb\_flush\_log\_at\_trx\_commit | 트랜잭션 커밋 시 로그 기록 방식을 제어하는 파라미터                            |

---

## 🔁 트랜잭션과 Undo 로그 흐름

### 트랜잭션이 시작되면:

1. **DML 수행 (INSERT/UPDATE/DELETE)**
   → 변경 전 값을 Undo 로그에 기록함
   → Undo는 Undo Tablespace에 저장됨

2. 트랜잭션마다 **Undo 슬롯 1개** 점유
   → 그 슬롯 안에는 여러 DML 명령어의 undo 정보가 쌓임

3. Undo 로그는 두 가지 용도

   * **롤백**할 때 이전 상태로 복구
   * **MVCC**: 다른 트랜잭션이 SELECT 시 일관된 버전을 제공

---

## 🧠 오래 열린 트랜잭션의 문제

* Undo 로그가 **정리되지 않고 계속 유지**
* → 새로운 SELECT 트랜잭션은 **과거 버전을 뒤지느라 성능 저하**
* 특히 **Repeatable Read** 격리 수준에서는 Undo 체인이 길어짐

---

## 🔧 Change Buffer 작동 원리

| 조건                             | 동작                                   |
| ------------------------------ | ------------------------------------ |
| 보조 인덱스 페이지가 **버퍼 풀에 없음**       | 디스크에서 읽어오지 않고 Change Buffer에 변경사항 기록 |
| 페이지가 나중에 SELECT 등으로 버퍼 풀에 올라오면 | → 그때 병합(Merge) 수행됨                   |

### 📌 주의

* **Primary Key 인덱스**는 Change Buffer 사용 ❌
  → 즉시 일관성 확보가 필요해서 항상 즉시 변경됨

---

## 🔐 Redo 로그와 로그 버퍼

### 역할

| 구성 요소   | 설명                                 |
| ------- | ---------------------------------- |
| 로그 버퍼   | Redo 로그를 메모리에 임시 저장. 커밋 시 디스크로 플러시 |
| Redo 로그 | 장애 시 복구용. 디스크에 저장되는 변경 정보          |
| COMMIT  | Redo 로그에 "커밋 마커"가 기록돼야 완료 인정됨      |

---

## 💾 `innodb_flush_log_at_trx_commit` 정리

| 값 | 동작                             | 장점/단점                     |
| - | ------------------------------ | ------------------------- |
| 1 | COMMIT 시마다 로그를 디스크에 flush      | 가장 안전 (100% 커밋 보장), 성능 부담 |
| 2 | COMMIT 시 로그 파일까지만, flush는 1초마다 | 약간 위험, 성능 향상              |
| 0 | 버퍼에만 저장, 1초마다 로그 파일 기록 및 flush | 커밋 손실 가능, 성능 최대           |

---

## 🔁 커밋 직후 장애 처리 시나리오

### 1. 커밋 마커까지 기록 완료

* → Redo 로그 Replay 시 트랜잭션 **재적용됨**
* → 데이터 반영됨

### 2. 커밋 마커 기록 전 장애

* → Redo 로그 Replay 시 트랜잭션 **무시됨**
* → 데이터 반영 ❌

> ❗ Undo 로그로 롤백하는 게 아니라, **애초에 없던 트랜잭션처럼 무시**

---

## 🧠 TIL 요약 인사이트

* InnoDB는 **트랜잭션 원자성**과 **데이터 일관성**을 철저히 보장한다.
* Undo 로그는 **변경 전 상태**를, Redo 로그는 **변경 후 상태**를 기록한다.
* 커밋은 **fsync까지 완료되어야 진짜 완료**된 것으로 인정된다.
* 오래 열린 트랜잭션은 **Undo 정리 지연 → SELECT 성능 저하**라는 문제를 유발한다.
* Change Buffer는 **디스크 IO 절약**을 위한 전략이지만, **Primary Key에는 적용되지 않는다.**


