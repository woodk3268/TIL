
# 📘 객체 분해 - TIL 정리 (오브젝트 Chapter 7)

---

## ✅ 학습 주제

* 하향식 기능 분해의 한계
* 정보 은닉, 모듈화, 데이터 추상화의 등장 배경
* 데이터 변경에 의한 파급효과
* 시급직 급여 계산 사례를 통한 구조적 문제 분석
* 객체지향적 해결책 (책임 분배, 메시지 중심 설계)

---

## 🧩 핵심 개념 요약

| 개념      | 설명                                                     |
| ------- | ------------------------------------------------------ |
| 기능 분해   | 시스템의 기능을 순차적 실행 흐름에 따라 하위 절차로 쪼개는 방식                   |
| 모듈      | 책임을 중심으로 내부 구현을 감추고, 인터페이스만 외부에 노출하는 단위                |
| 정보 은닉   | 변경 가능성 있는 내부 데이터를 숨기고, 외부에는 메시지만 제공하여 결합도를 낮추는 설계 원칙   |
| 데이터 추상화 | 데이터 구조가 아닌 동작(메서드)을 중심으로 객체와의 상호작용을 설계하는 방식            |
| 파급효과    | 데이터 변경이 전체 시스템에 영향을 끼치는 현상. 예: 배열 구조 변경으로 여러 함수가 깨짐    |
| OCP     | Open-Closed Principle. 기존 코드를 수정하지 않고 기능을 확장할 수 있도록 설계 |

---

## 🧠 주요 인사이트

### ❗ 하향식 기능 분해의 문제점

| 문제                  | 설명                                                      |
| ------------------- | ------------------------------------------------------- |
| 변경에 약함              | 새로운 기능이 생기면 기존 함수들을 계속 수정해야 함 (`calculatePay`에 조건 추가 등) |
| 조건문 중복              | 타입 분기에 따라 동작이 갈리는 조건문이 여러 군데 존재함                        |
| 데이터 중심 설계 → 파급효과 발생 | 배열 하나(basePays) 바꾸면 시스템 전체가 영향을 받음                      |
| 흐름 중심 설계 → 유연성 부족   | 실행 순서가 고정되면 나중에 UI, 정책이 바뀔 때 적용 어려움                     |

---

## 🔍 사례: 시급직 직원 추가 시 발생한 문제

### 🧨 기존 구조

* `employees`, `basePays` 배열로 급여 계산
* `hourly?` 조건이 각 함수에 중복됨
* `sumOfBasePays()`는 아르바이트 고려 안 해서 버그 발생

### 🎯 원인

* 데이터와 책임이 분리되어 있음
* 데이터의 해석이 각 함수마다 다르게 되어 있음
* 변경 사항이 코드 전체에 퍼짐 (파급효과 발생)

### ✅ 해결책 (객체지향 방식)

| 방법                    | 설명                                                                |
| --------------------- | ----------------------------------------------------------------- |
| 급여 계산 책임을 객체에 위임      | `FullTimeEmployee`, `HourlyEmployee`로 분리 후 각각 `calculatePay()` 구현 |
| 데이터 해석 대신 메시지 전송      | 외부는 `employee.calculatePay()`만 호출                                 |
| sumOfBasePays도 메시지 기반 | 내부 로직 몰라도 전체 합 계산 가능, 책임 은닉                                       |

---

## 🧱 설계 원칙 적용 정리

| 원칙             | 적용 사례                           |
| -------------- | ------------------------------- |
| SRP (단일 책임 원칙) | 직원 타입마다 급여 계산 책임 분리             |
| OCP            | 기존 코드 수정 없이 시급직 추가 가능           |
| 캡슐화            | 직원 데이터(시간, 시급 등)를 클래스 내부에 숨김    |
| 메시지 중심 설계      | 객체에게 무엇을 할지 말하고, 어떻게 할지는 객체가 결정 |

---

## 💡 객체 분해를 위한 핵심 전환

| 기능 중심 사고 → 객체 중심 사고       |
| ------------------------- |
| "무엇을 해야 하는가" → "누가 책임지는가" |
| 조건문 분기 → 메시지 위임           |
| 공유 데이터 → 캡슐화된 객체 상태       |
| 전역 로직 → 객체 내부 책임 분배       |

---

## ✏️ 오늘의 정리 문장

> **“기능은 흐름을 구성하지만, 객체는 책임을 감춘다.
> 진짜 유연한 시스템은 책임이 잘 분리된 시스템이다.”**

